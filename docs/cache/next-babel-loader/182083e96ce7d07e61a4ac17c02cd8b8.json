{"ast":null,"code":"import _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\n\n/**\n * NEXT.JS Get markdown file api\n * INFO: This is the api file that is used the built in markdown React component, the component\n *       sends all requests according to it's children or source attribute. The API will search all directories\n *       defined in main configuration file's markdown section 'markdown-file-paths' or use the special mapping\n *       configuration for specially mapped files.\n */\n// IMPORTS\nimport reqLog from './_req-log';\nimport { markdown_config } from 'config';\nimport fs from 'fs';\nimport path from 'path'; // export via task router\n\nexport default ((req, res) => router.call(this, req, res)); // pass request to task router\n// Global Variable declarations\n\nconst // declare variables\nmode = process.env.NODE_ENV === 'development',\n      showReqLog = markdown_config['show-api-request-log'],\n      // checks the console request log switch\n// declare functions\n// mdFiles = mode ? './public/markdown/' : './markdown/',\n// readDirectory = Dir => fs.readdirSync(path.resolve(mdFiles, Dir)),\nmdFiles = './public/markdown/',\n      getFile = (file, filePath = mdFiles) => {\n  var fp = filePath + file;\n  console.log('fp: ', fp);\n  return fs.readFileSync(fp, 'utf8');\n},\n      createErrorResponse = (status, type, message) => {\n  throw new Error(_JSON$stringify({\n    status,\n    type,\n    message\n  }));\n}; // declare universal variable\n// let filePath = null;\n\n/**\n * TASK ROUTER\n */\n\n\nfunction router(req, res) {\n  console.log('API Received request');\n  showReqLog && console.log('PROCESS CWD: ', process.cwd());\n  showReqLog && console.log('THIS DIR: ', __dirname);\n  showReqLog && console.log('READING DIR: ', mdFiles);\n  showReqLog && reqLog(req); // switch is in /src/config/conf.json\n  // filePath = null; // set global variable to null\n\n  try {\n    // try and run the readfile function\n    readFile.call(this, req.query.file, body => res.status(200).send(body));\n  } catch (err) {\n    // if an error occurs by means of createErrorResponse\n    console.error('ERROR Message:', err.message); // show error message in the console\n\n    console.error('STACK:', err.stack); // shoe error stack in the console\n\n    let status; // declare status\n\n    try {\n      // try and read message returned by createErrorResponse (Should always be JSON)\n      status = JSON.parse(err.message).status; // convert to json to get status code\n    } catch (err) {\n      // if not a json object (error should be unknown and then must be debugged)\n      status = 500; // set status to internal server error code\n    }\n\n    res.status(status).send(err.message); // send response\n  }\n}\n/**\n * READFILE: The function the reads the file after the path has been determined\n */\n\n\nfunction readFile(fileName, callback) {\n  // \tconsole.log('fileName: ', fileName);\n  //     let\n  //         body = {}; // set body\n  //     if (findFile(fileName) !== null) { // if the file is found\n  //         body = getFile(filePath) // set body if the file is not found\n  //     } else { // if file is not found\n  //         createErrorResponse(404, 'fileNotExist', `The file '${fileName}' does not exist.`); // create error response\n  //     }\n  //     callback(body)\n  try {\n    // if (fileName === 'README') {\n    // callback(getFile(fileName + '.md', process.cwd()))\n    // } else {\n    callback(getFile(fileName + '.md')); // }\n  } catch (err) {\n    createErrorResponse(404, 'fileNotExist', `The file '${fileName}' does not exist.`);\n  }\n} // /**\n//  * FIND THE REQUESTED FILE:\n//  */\n// function findFile(fileName) {\n// \tconsole.log('fileName: ', fileName);\n//     // if (checkIfMapped(fileName) && mode) return filePath; // check if mapping exists for request query\n// \tconst file = fileName + '.md'; // append file extension to name\n// \tconsole.log('file: ', file);\n//     // for (let i = 0; i < filePaths.length; i++) { // loop through the paths\n//     // const checkPath = filePaths[i]; // set path for this iteration\n//     try { // try and read the directory\n//         if (readDirectory(mdFiles).includes(file)) { // if the read directory contains the file\n//             return path.join(mdFiles, file); // return the filepath\n//             // break; // stop the loop if the file is found\n//         } else {\n//             throw new Error(fileName)\n//         }\n//     } catch (error) { // if the directory cannot be read\n//         createErrorResponse(404, 'invPath', `The path '${error.message}' does not exist.`); // create error response\n//     }\n//     // }\n// }\n\n/**\n * CHECKIFMAPPED: check if a mapping exists for the requested file\n */\n// function checkIfMapped(fileName) {\n//     const fileMapping = pageMap.filter(p => p.requestedAs === fileName); // try and find a mapping\n//     if (fileMapping.length > 0) { // if mapping exists\n//         filePath = fileMapping[0].located; // get the location per the mapping\n//         return filePath; // return the file path per the mapping\n//     } else { // if no mapping exists\n//         return null; // return null\n//     }\n// }","map":{"version":3,"sources":["/Users/cliff/git/next-app-pre-configured-starter/src/pages/api/get-file.js"],"names":["reqLog","markdown_config","fs","path","req","res","router","call","mode","process","env","NODE_ENV","showReqLog","mdFiles","getFile","file","filePath","fp","console","log","readFileSync","createErrorResponse","status","type","message","Error","cwd","__dirname","readFile","query","body","send","err","error","stack","JSON","parse","fileName","callback"],"mappings":"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","sourcesContent":["/**\n * NEXT.JS Get markdown file api\n * INFO: This is the api file that is used the built in markdown React component, the component\n *       sends all requests according to it's children or source attribute. The API will search all directories\n *       defined in main configuration file's markdown section 'markdown-file-paths' or use the special mapping\n *       configuration for specially mapped files.\n */\n// IMPORTS\nimport reqLog from './_req-log';\nimport { markdown_config } from 'config';\nimport fs from 'fs';\nimport path from 'path';\n// export via task router\nexport default (req, res) => router.call(this, req, res); // pass request to task router\n// Global Variable declarations\nconst\n\t// declare variables\n\tmode = process.env.NODE_ENV === 'development',\n\tshowReqLog = markdown_config['show-api-request-log'], // checks the console request log switch\n\t// declare functions\n\t\n\t// mdFiles = mode ? './public/markdown/' : './markdown/',\n\t// readDirectory = Dir => fs.readdirSync(path.resolve(mdFiles, Dir)),\n\tmdFiles = './public/markdown/',\n\tgetFile = (file, filePath = mdFiles) => {\n\t\tvar fp=filePath+file;\n\t\tconsole.log('fp: ', fp);\n\t\treturn fs.readFileSync(fp, 'utf8')\n},\n\tcreateErrorResponse = (status, type, message) => { throw new Error(JSON.stringify({ status, type, message })) };\n// declare universal variable\n// let filePath = null;\n/**\n * TASK ROUTER\n */\nfunction router(req, res) {\n\tconsole.log('API Received request');\n\tshowReqLog && console.log('PROCESS CWD: ', process.cwd());\n\tshowReqLog && console.log('THIS DIR: ', __dirname);\n\tshowReqLog && console.log('READING DIR: ', mdFiles);\n\tshowReqLog && reqLog(req); // switch is in /src/config/conf.json\n\t// filePath = null; // set global variable to null\n\ttry { // try and run the readfile function\n\t\treadFile.call(this, req.query.file, body => res.status(200).send(body));\n\t} catch (err) { // if an error occurs by means of createErrorResponse\n\t\tconsole.error('ERROR Message:', err.message); // show error message in the console\n\t\tconsole.error('STACK:', err.stack); // shoe error stack in the console\n\t\tlet status; // declare status\n\t\ttry { // try and read message returned by createErrorResponse (Should always be JSON)\n\t\t\tstatus = JSON.parse(err.message).status // convert to json to get status code\n\t\t} catch (err) { // if not a json object (error should be unknown and then must be debugged)\n\t\t\tstatus = 500; // set status to internal server error code\n\t\t}\n\t\tres.status(status).send(err.message); // send response\n\t}\n}\n/**\n * READFILE: The function the reads the file after the path has been determined\n */\nfunction readFile(fileName, callback) {\n\t// \tconsole.log('fileName: ', fileName);\n\t//     let\n\t//         body = {}; // set body\n\t//     if (findFile(fileName) !== null) { // if the file is found\n\t//         body = getFile(filePath) // set body if the file is not found\n\t//     } else { // if file is not found\n\t//         createErrorResponse(404, 'fileNotExist', `The file '${fileName}' does not exist.`); // create error response\n\t//     }\n\t//     callback(body)\n\ttry {\n\t\t// if (fileName === 'README') {\n\t\t\t// callback(getFile(fileName + '.md', process.cwd()))\n\t\t// } else {\n\t\t\tcallback(getFile(fileName + '.md'))\n\t\t// }\n\t} catch (err) {\n\t\tcreateErrorResponse(404, 'fileNotExist', `The file '${fileName}' does not exist.`);\n\t}\n\n}\n// /**\n//  * FIND THE REQUESTED FILE:\n//  */\n// function findFile(fileName) {\n// \tconsole.log('fileName: ', fileName);\n//     // if (checkIfMapped(fileName) && mode) return filePath; // check if mapping exists for request query\n// \tconst file = fileName + '.md'; // append file extension to name\n// \tconsole.log('file: ', file);\n//     // for (let i = 0; i < filePaths.length; i++) { // loop through the paths\n//     // const checkPath = filePaths[i]; // set path for this iteration\n//     try { // try and read the directory\n//         if (readDirectory(mdFiles).includes(file)) { // if the read directory contains the file\n//             return path.join(mdFiles, file); // return the filepath\n//             // break; // stop the loop if the file is found\n//         } else {\n//             throw new Error(fileName)\n//         }\n//     } catch (error) { // if the directory cannot be read\n//         createErrorResponse(404, 'invPath', `The path '${error.message}' does not exist.`); // create error response\n//     }\n//     // }\n\n// }\n/**\n * CHECKIFMAPPED: check if a mapping exists for the requested file\n */\n// function checkIfMapped(fileName) {\n//     const fileMapping = pageMap.filter(p => p.requestedAs === fileName); // try and find a mapping\n//     if (fileMapping.length > 0) { // if mapping exists\n//         filePath = fileMapping[0].located; // get the location per the mapping\n//         return filePath; // return the file path per the mapping\n//     } else { // if no mapping exists\n//         return null; // return null\n//     }\n// }"]},"metadata":{},"sourceType":"module"}